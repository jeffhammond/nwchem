      SUBROUTINE ccsd_t2_7_3_mp(d_a,k_a_offset,d_b,k_b_offset,d_c,
     &     k_c_offset, maxh, maxp, prec)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i1 ( h6 p3 h1 p5 )_vt + = -1/2 * Sum ( h8 p7 ) * t ( p3 p7 h1 h8 )_t * v ( h6 h8 p5 p7 )_v
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      integer, parameter :: sp = selected_real_kind(6, 37)
      integer, parameter :: dp = selected_real_kind(15, 307)
      INTEGER prec
      INTEGER d_a
      INTEGER k_a_offset
      INTEGER d_b
      INTEGER k_b_offset
      INTEGER d_c
      INTEGER k_c_offset
      INTEGER NXTASK
      INTEGER next
      INTEGER nprocs
      INTEGER count
      INTEGER p3b
      INTEGER h6b
      INTEGER h1b
      INTEGER p5b
      INTEGER dimc
      INTEGER l_cs
      INTEGER k_cs
      INTEGER p7b
      INTEGER h8b
      INTEGER p3b_1
      INTEGER p7b_1
      INTEGER h1b_1
      INTEGER h8b_1
      INTEGER h6b_2
      INTEGER h8b_2
      INTEGER p5b_2
      INTEGER p7b_2
      INTEGER dim_common
      INTEGER dima_sort
      INTEGER dima
      INTEGER dimb_sort
      INTEGER dimb
      INTEGER l_as
      INTEGER k_as
      INTEGER l_a
      INTEGER k_a
      INTEGER l_bs
      INTEGER k_bs
      INTEGER l_b
      INTEGER k_b
      INTEGER l_c
      INTEGER k_c
      INTEGER maxh, maxp, dimhhpp
      integer p7b_in,h8b_in
      EXTERNAL NXTASK
      real(kind=dp), allocatable :: df_t(:)
      real(kind=sp), allocatable :: sf_a(:)
      real(kind=sp), allocatable :: sf_b(:)
      real(kind=sp), allocatable :: sf_c(:)
      integer :: e_a,e_b,e_c,e_t
      integer :: splita, splitb, muls
      character*1 modetype
      nprocs = GA_NNODES()
      count = 0
      next = NXTASK(nprocs, 1)

      dimhhpp = maxh*maxh*maxp*maxp

      allocate(sf_a(1:dimhhpp),stat=e_a)
      allocate(sf_b(1:dimhhpp),stat=e_b)
      allocate(sf_c(1:dimhhpp),stat=e_c)
      allocate(df_t(1:dimhhpp),stat=e_t)
      if (e_a.ne.0) call errquit("MA a",dimhhpp,MA_ERR)
      if (e_b.ne.0) call errquit("MA b",dimhhpp,MA_ERR)
      if (e_c.ne.0) call errquit("MA c",dimhhpp,MA_ERR)
      if (e_t.ne.0) call errquit("MA t",dimhhpp,MA_ERR)

      DO p3b = noab+1,noab+nvab
      DO h1b = 1,noab
      DO p5b = noab+1,noab+nvab
      DO h6b = 1,noab
      IF ((.not.restricted).or.(int_mb(k_spin+p3b-1)+int_mb(k_spin+h6b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+p5b-1).ne.8)) THEN
      IF (int_mb(k_spin+p3b-1)+int_mb(k_spin+h6b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+p5b-1)) THEN
      IF (ieor(int_mb(k_sym+p3b-1),ieor(int_mb(k_sym+h6b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+p5b-1)))) .eq. ieor(irrep_v,irrep_t)) TH
     &EN
      IF (next.eq.count) THEN
      dimc = int_mb(k_range+p3b-1) * int_mb(k_range+h6b-1) * int_mb(k_ra
     &nge+h1b-1) * int_mb(k_range+p5b-1)
      CALL SFILL(dimc,0.0,sf_c,1)
#if 0
      DO h8b = 1,noab
      DO p7b = noab+1,noab+nvab
#else
      do h8b_in=ga_nodeid(),ga_nodeid()+noab-1
         h8b=mod(h8b_in,noab)+1
         do p7b_in=ga_nodeid()+1,ga_nodeid()+nvab
            p7b=mod(p7b_in,nvab)+noab+1

#endif
      IF (int_mb(k_spin+p3b-1)+int_mb(k_spin+p7b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+h8b-1)) THEN
      IF (ieor(int_mb(k_sym+p3b-1),ieor(int_mb(k_sym+p7b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+h8b-1)))) .eq. irrep_t) THEN
      CALL TCE_RESTRICTED_4(p3b,p7b,h1b,h8b,p3b_1,p7b_1,h1b_1,h8b_1)
      CALL TCE_RESTRICTED_4(h6b,h8b,p5b,p7b,h6b_2,h8b_2,p5b_2,p7b_2)
      dim_common = int_mb(k_range+p7b-1) * int_mb(k_range+h8b-1)
      dima_sort = int_mb(k_range+p3b-1) * int_mb(k_range+h1b-1)
      dima = dim_common * dima_sort
      dimb_sort = int_mb(k_range+h6b-1) * int_mb(k_range+p5b-1)
      dimb = dim_common * dimb_sort
      IF ((dima .gt. 0) .and. (dimb .gt. 0)) THEN
      IF ((p7b .lt. p3b) .and. (h8b .lt. h1b)) THEN
      CALL GET_HASH_BLOCK(d_a,df_t,dima,int_mb(k_a_offset),(h1b_1
     & - 1 + noab * (h8b_1 - 1 + noab * (p3b_1 - noab - 1 + nvab * (p7b_
     &1 - noab - 1)))))
      CALL TCE_SORT_4_mp_d2s(df_t,sf_a,int_mb(k_range+p7b-1)
     &,int_mb(k_range+p3b-1),int_mb(k_range+h8b-1),int_mb(k_range+h1b-1)
     &,4,2,3,1,1.0d0)
      END IF
      IF ((p7b .lt. p3b) .and. (h1b .le. h8b)) THEN
      CALL GET_HASH_BLOCK(d_a,df_t,dima,int_mb(k_a_offset),(h8b_1
     & - 1 + noab * (h1b_1 - 1 + noab * (p3b_1 - noab - 1 + nvab * (p7b_
     &1 - noab - 1)))))
      CALL TCE_SORT_4_mp_d2s(df_t,sf_a,int_mb(k_range+p7b-1)
     &,int_mb(k_range+p3b-1),int_mb(k_range+h1b-1),int_mb(k_range+h8b-1)
     &,3,2,4,1,-1.0d0)
      END IF
      IF ((p3b .le. p7b) .and. (h8b .lt. h1b)) THEN
      CALL GET_HASH_BLOCK(d_a,df_t,dima,int_mb(k_a_offset),(h1b_1
     & - 1 + noab * (h8b_1 - 1 + noab * (p7b_1 - noab - 1 + nvab * (p3b_
     &1 - noab - 1)))))
      CALL TCE_SORT_4_mp_d2s(df_t,sf_a,int_mb(k_range+p3b-1)
     &,int_mb(k_range+p7b-1),int_mb(k_range+h8b-1),int_mb(k_range+h1b-1)
     &,4,1,3,2,-1.0d0)
      END IF
      IF ((p3b .le. p7b) .and. (h1b .le. h8b)) THEN
      CALL GET_HASH_BLOCK(d_a,df_t,dima,int_mb(k_a_offset),(h8b_1
     & - 1 + noab * (h1b_1 - 1 + noab * (p7b_1 - noab - 1 + nvab * (p3b_
     &1 - noab - 1)))))
      CALL TCE_SORT_4_mp_d2s(df_t,sf_a,int_mb(k_range+p3b-1)
     &,int_mb(k_range+p7b-1),int_mb(k_range+h1b-1),int_mb(k_range+h8b-1)
     &,3,1,4,2,1.0d0)
      END IF
      IF ((h8b .lt. h6b) .and. (p7b .lt. p5b)) THEN
      if(.not.intorb) then
      CALL GET_HASH_BLOCK(d_b,df_t,dimb,int_mb(k_b_offset),(p5b_2
     & - 1 + (noab+nvab) * (p7b_2 - 1 + (noab+nvab) * (h6b_2 - 1 + (noab
     &+nvab) * (h8b_2 - 1)))))
      else
      CALL GET_HASH_BLOCK_I(d_b,df_t,dimb,int_mb(k_b_offset),
     &(p5b_2
     & - 1 + (noab+nvab) * (p7b_2 - 1 + (noab+nvab) * (h6b_2 - 1 + (noab
     &+nvab) * (h8b_2 - 1)))),p5b_2,p7b_2,h6b_2,h8b_2)
      end if
      CALL TCE_SORT_4_mp_d2s(df_t,sf_b,int_mb(k_range+h8b-1)
     &,int_mb(k_range+h6b-1),int_mb(k_range+p7b-1),int_mb(k_range+p5b-1)
     &,4,2,1,3,1.0d0)
      END IF
      IF ((h8b .lt. h6b) .and. (p5b .le. p7b)) THEN
      if(.not.intorb) then
      CALL GET_HASH_BLOCK(d_b,df_t,dimb,int_mb(k_b_offset),(p7b_2
     & - 1 + (noab+nvab) * (p5b_2 - 1 + (noab+nvab) * (h6b_2 - 1 + (noab
     &+nvab) * (h8b_2 - 1)))))
      else
      CALL GET_HASH_BLOCK_I(d_b,df_t,dimb,int_mb(k_b_offset),
     &(p7b_2
     & - 1 + (noab+nvab) * (p5b_2 - 1 + (noab+nvab) * (h6b_2 - 1 + (noab
     &+nvab) * (h8b_2 - 1)))),p7b_2,p5b_2,h6b_2,h8b_2)
      end if
      CALL TCE_SORT_4_mp_d2s(df_t,sf_b,int_mb(k_range+h8b-1)
     &,int_mb(k_range+h6b-1),int_mb(k_range+p5b-1),int_mb(k_range+p7b-1)
     &,3,2,1,4,-1.0d0)
      END IF
      IF ((h6b .le. h8b) .and. (p7b .lt. p5b)) THEN
      if(.not.intorb) then
      CALL GET_HASH_BLOCK(d_b,df_t,dimb,int_mb(k_b_offset),(p5b_2
     & - 1 + (noab+nvab) * (p7b_2 - 1 + (noab+nvab) * (h8b_2 - 1 + (noab
     &+nvab) * (h6b_2 - 1)))))
      else
      CALL GET_HASH_BLOCK_I(d_b,df_t,dimb,int_mb(k_b_offset),
     &(p5b_2
     & - 1 + (noab+nvab) * (p7b_2 - 1 + (noab+nvab) * (h8b_2 - 1 + (noab
     &+nvab) * (h6b_2 - 1)))),p5b_2,p7b_2,h8b_2,h6b_2)
      end if
      CALL TCE_SORT_4_mp_d2s(df_t,sf_b,int_mb(k_range+h6b-1)
     &,int_mb(k_range+h8b-1),int_mb(k_range+p7b-1),int_mb(k_range+p5b-1)
     &,4,1,2,3,-1.0d0)
      END IF
      IF ((h6b .le. h8b) .and. (p5b .le. p7b)) THEN
      if(.not.intorb) then
      CALL GET_HASH_BLOCK(d_b,df_t,dimb,int_mb(k_b_offset),(p7b_2
     & - 1 + (noab+nvab) * (p5b_2 - 1 + (noab+nvab) * (h8b_2 - 1 + (noab
     &+nvab) * (h6b_2 - 1)))))
      else
      CALL GET_HASH_BLOCK_I(d_b,df_t,dimb,int_mb(k_b_offset),
     &(p7b_2
     & - 1 + (noab+nvab) * (p5b_2 - 1 + (noab+nvab) * (h8b_2 - 1 + (noab
     &+nvab) * (h6b_2 - 1)))),p7b_2,p5b_2,h8b_2,h6b_2)
      end if
      CALL TCE_SORT_4_mp_d2s(df_t,sf_b,int_mb(k_range+h6b-1)
     &,int_mb(k_range+h8b-1),int_mb(k_range+p5b-1),int_mb(k_range+p7b-1)
     &,3,1,2,4,1.0d0)
      END IF
      if(prec.eq.2) then
         call truncate_sp2hp(sf_a, dimhhpp)
         call truncate_sp2hp(sf_b, dimhhpp)
      else if(prec.eq.1) then
         call truncate_sp2bf(sf_a, dimhhpp)
         call truncate_sp2bf(sf_b, dimhhpp)
      endif
!     prec = 1: BF16x1
!     prec = 2: FP16x1
!     prec = 3: FP32
!     prec = 4: FP64: I have no idea how this is done...
!     prec = 5: BF16x2
!     prec = 6: BF16x3
!     prec = 7: FP16x2
!     prec = 8: FP16x3
      if ( (prec .eq. 1) .or. (prec .eq. 5) .or. (prec .eq. 6) ) then
         modetype = 'B'
      else if ( (prec.eq.2) .or. (prec.eq.7) .or. (prec .eq. 8) ) then
         modetype = 'F'
      endif
      if ( (prec .eq. 5) .or. (prec .eq. 7) ) then
         splita = 2
         splitb = 2
         muls = 3
      endif
      if ( (prec .eq. 6) .or. (prec .eq. 8) ) then
         splita = 3
         splitb = 3
         muls = 6
      endif
      if ( prec .eq. 3 ) then
      CALL SGEMM('T','N',dima_sort,dimb_sort,dim_common,1.0,sf_a
     &,dim_common,sf_b,dim_common,1.0,sf_c, dima_sort)
      else if ( (prec .ge. 5) .and. (prec .le. 8) ) then
      call sgemmreplacement('T','N',dima_sort,dimb_sort,dim_common,1.0
     &,sf_a,dim_common,sf_b,dim_common,1.0,sf_c,dima_sort,splita,splitb
     &,muls,modetype)
      endif
      if(prec.eq.2) then
         call truncate_sp2hp(sf_c, dimhhpp)
      else if(prec.eq.1) then
         call truncate_sp2bf(sf_c, dimhhpp)
      endif
      END IF
      END IF
      END IF
      END DO
      END DO
      CALL TCE_SORT_4_mp_s2d(sf_c,df_t,int_mb(k_range+p5b-1)
     &,int_mb(k_range+h6b-1),int_mb(k_range+h1b-1),int_mb(k_range+p3b-1)
     &,4,2,3,1,-1.0d0/2.0d0)
      CALL ADD_HASH_BLOCK(d_c,df_t,dimc,int_mb(k_c_offset),
     &(h6b -1 + noab * (p5b - noab -1 +nvab * (h1b - 1 + noab *
     &( p3b - noab -1 )))))
      next = NXTASK(nprocs, 1)
      END IF
      count = count + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      next = NXTASK(-nprocs, 1)
      call GA_SYNC()

      deallocate(sf_a,stat=e_a)
      deallocate(sf_b,stat=e_b)
      deallocate(sf_c,stat=e_c)
      deallocate(df_t,stat=e_t)
      if (e_a.ne.0) call errquit("MA pops a",0,MA_ERR)
      if (e_b.ne.0) call errquit("MA pops b",0,MA_ERR)
      if (e_c.ne.0) call errquit("MA pops c",0,MA_ERR)
      if (e_t.ne.0) call errquit("MA pops t",1,MA_ERR)
      RETURN
      END

      SUBROUTINE ccsd_t2_7_mp(d_a,k_a_offset,d_b,k_b_offset,d_c,
     &     k_c_offset, maxh, maxp, prec)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i0 ( p3 p4 h1 h2 )_vt + = -1 * P( 4 ) * Sum ( h6 p5 ) * t ( p3 p5 h1 h6 )_t * i1 ( h6 p4 h2 p5 )_v
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      integer, parameter :: sp = selected_real_kind(6, 37)
      integer, parameter :: dp = selected_real_kind(15, 307)
      INTEGER prec
      INTEGER d_a
      INTEGER k_a_offset
      INTEGER d_b
      INTEGER k_b_offset
      INTEGER d_c
      INTEGER k_c_offset
      INTEGER NXTASK
      INTEGER next
      INTEGER nprocs
      INTEGER count
      INTEGER p3b
      INTEGER p4b
      INTEGER h1b
      INTEGER h2b
      INTEGER dimc
      INTEGER l_cs
      INTEGER k_cs
      INTEGER p5b
      INTEGER h6b
      INTEGER p3b_1
      INTEGER p5b_1
      INTEGER h1b_1
      INTEGER h6b_1
      INTEGER p4b_2
      INTEGER h6b_2
      INTEGER h2b_2
      INTEGER p5b_2
      INTEGER dim_common
      INTEGER dima_sort
      INTEGER dima
      INTEGER dimb_sort
      INTEGER dimb
      INTEGER l_as
      INTEGER k_as
      INTEGER l_a
      INTEGER k_a
      INTEGER l_bs
      INTEGER k_bs
      INTEGER l_b
      INTEGER k_b
      INTEGER l_c
      INTEGER k_c
      INTEGER maxh, maxp, dimhhpp
      EXTERNAL NXTASK
      real(kind=dp), allocatable :: df_t(:)
      real(kind=sp), allocatable :: sf_a(:)
      real(kind=sp), allocatable :: sf_b(:)
      real(kind=sp), allocatable :: sf_c(:)
      integer :: e_a,e_b,e_c,e_t
      integer :: splita, splitb, muls
      character*1 modetype
      nprocs = GA_NNODES()
      count = 0
      next = NXTASK(nprocs, 1)

      dimhhpp = maxh*maxh*maxp*maxp

      allocate(sf_a(1:dimhhpp),stat=e_a)
      allocate(sf_b(1:dimhhpp),stat=e_b)
      allocate(sf_c(1:dimhhpp),stat=e_c)
      allocate(df_t(1:dimhhpp),stat=e_t)
      if (e_a.ne.0) call errquit("MA a",dimhhpp,MA_ERR)
      if (e_b.ne.0) call errquit("MA b",dimhhpp,MA_ERR)
      if (e_c.ne.0) call errquit("MA c",dimhhpp,MA_ERR)
      if (e_t.ne.0) call errquit("MA t",dimhhpp,MA_ERR)

      DO p3b = noab+1,noab+nvab
      DO p4b = noab+1,noab+nvab
      DO h1b = 1,noab
      DO h2b = 1,noab
      IF ((.not.restricted).or.(int_mb(k_spin+p3b-1)+int_mb(k_spin+p4b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1).ne.8)) THEN
      IF (int_mb(k_spin+p3b-1)+int_mb(k_spin+p4b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+h2b-1)) THEN
      IF (ieor(int_mb(k_sym+p3b-1),ieor(int_mb(k_sym+p4b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+h2b-1)))) .eq. ieor(irrep_v,irrep_t)) TH
     &EN
      IF (next.eq.count) THEN
      dimc = int_mb(k_range+p3b-1) * int_mb(k_range+p4b-1) * int_mb(k_ra
     &nge+h1b-1) * int_mb(k_range+h2b-1)
      CALL SFILL(dimc,0.0,sf_c,1)
      DO p5b = noab+1,noab+nvab
      DO h6b = 1,noab
      IF (int_mb(k_spin+p3b-1)+int_mb(k_spin+p5b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+h6b-1)) THEN
      IF (ieor(int_mb(k_sym+p3b-1),ieor(int_mb(k_sym+p5b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+h6b-1)))) .eq. irrep_t) THEN
      CALL TCE_RESTRICTED_4(p3b,p5b,h1b,h6b,p3b_1,p5b_1,h1b_1,h6b_1)
      CALL TCE_RESTRICTED_4(p4b,h6b,h2b,p5b,p4b_2,h6b_2,h2b_2,p5b_2)
      dim_common = int_mb(k_range+p5b-1) * int_mb(k_range+h6b-1)
      dima_sort = int_mb(k_range+p3b-1) * int_mb(k_range+h1b-1)
      dima = dim_common * dima_sort
      dimb_sort = int_mb(k_range+p4b-1) * int_mb(k_range+h2b-1)
      dimb = dim_common * dimb_sort
      IF ((dima .gt. 0) .and. (dimb .gt. 0)) THEN
      IF ((p5b .lt. p3b) .and. (h6b .lt. h1b)) THEN
      CALL GET_HASH_BLOCK(d_a,df_t,dima,int_mb(k_a_offset),(h1b_1
     & - 1 + noab * (h6b_1 - 1 + noab * (p3b_1 - noab - 1 + nvab * (p5b_
     &1 - noab - 1)))))
      CALL TCE_SORT_4_mp_d2s(df_t,sf_a,int_mb(k_range+p5b-1)
     &,int_mb(k_range+p3b-1),int_mb(k_range+h6b-1),int_mb(k_range+h1b-1)
     &,4,2,3,1,1.0d0)
      END IF
      IF ((p5b .lt. p3b) .and. (h1b .le. h6b)) THEN
      CALL GET_HASH_BLOCK(d_a,df_t,dima,int_mb(k_a_offset),(h6b_1
     & - 1 + noab * (h1b_1 - 1 + noab * (p3b_1 - noab - 1 + nvab * (p5b_
     &1 - noab - 1)))))
      CALL TCE_SORT_4_mp_d2s(df_t,sf_a,int_mb(k_range+p5b-1)
     &,int_mb(k_range+p3b-1),int_mb(k_range+h1b-1),int_mb(k_range+h6b-1)
     &,3,2,4,1,-1.0d0)
      END IF
      IF ((p3b .le. p5b) .and. (h6b .lt. h1b)) THEN
      CALL GET_HASH_BLOCK(d_a,df_t,dima,int_mb(k_a_offset),(h1b_1
     & - 1 + noab * (h6b_1 - 1 + noab * (p5b_1 - noab - 1 + nvab * (p3b_
     &1 - noab - 1)))))
      CALL TCE_SORT_4_mp_d2s(df_t,sf_a,int_mb(k_range+p3b-1)
     &,int_mb(k_range+p5b-1),int_mb(k_range+h6b-1),int_mb(k_range+h1b-1)
     &,4,1,3,2,-1.0d0)
      END IF
      IF ((p3b .le. p5b) .and. (h1b .le. h6b)) THEN
      CALL GET_HASH_BLOCK(d_a,df_t,dima,int_mb(k_a_offset),(h6b_1
     & - 1 + noab * (h1b_1 - 1 + noab * (p5b_1 - noab - 1 + nvab * (p3b_
     &1 - noab - 1)))))
      CALL TCE_SORT_4_mp_d2s(df_t,sf_a,int_mb(k_range+p3b-1)
     &,int_mb(k_range+p5b-1),int_mb(k_range+h1b-1),int_mb(k_range+h6b-1)
     &,3,1,4,2,1.0d0)
      END IF
      CALL GET_HASH_BLOCK(d_b,df_t,dimb,int_mb(k_b_offset),
     &(h6b_2 -1 + noab * (p5b_2 - noab -1 +nvab * (h2b_2 - 1 + noab *
     &( p4b_2 - noab -1 )))))
      CALL TCE_SORT_4_mp_d2s(df_t,sf_b,int_mb(k_range+p4b-1)
     &,int_mb(k_range+h6b-1),int_mb(k_range+h2b-1),int_mb(k_range+p5b-1)
     &,3,1,2,4,1.0d0)
      if(prec.eq.2) then
        call truncate_sp2hp(sf_a, dimhhpp)
        call truncate_sp2hp(sf_b, dimhhpp)
      else if(prec.eq.1) then
        call truncate_sp2bf(sf_a, dimhhpp)
        call truncate_sp2bf(sf_b, dimhhpp)
      endif
!     prec = 1: BF16x1
!     prec = 2: FP16x1
!     prec = 3: FP32
!     prec = 4: FP64: I have no idea how this is done...
!     prec = 5: BF16x2
!     prec = 6: BF16x3
!     prec = 7: FP16x2
!     prec = 8: FP16x3
      if ( (prec .eq. 1) .or. (prec .eq. 5) .or. (prec .eq. 6) ) then
         modetype = 'B'
      else if ( (prec.eq.2) .or. (prec.eq.7) .or. (prec .eq. 8) ) then
         modetype = 'F'
      endif
      if ( (prec .eq. 5) .or. (prec .eq. 7) ) then
         splita = 2
         splitb = 2
         muls = 3
      endif
      if ( (prec .eq. 6) .or. (prec .eq. 8) ) then
         splita = 3
         splitb = 3
         muls = 6
      endif
      if ( prec .eq. 3 ) then
         CALL SGEMM('T','N',dima_sort,dimb_sort,dim_common,1.0,sf_a
     &,dim_common,sf_b,dim_common,1.0,sf_c, dima_sort)
      else if ( (prec .ge. 5) .and. (prec .le. 8) ) then
         call sgemmreplacement('T','N',dima_sort,dimb_sort,dim_common,1.0
     &,sf_a,dim_common,sf_b,dim_common,1.0,sf_c,dima_sort,splita,splitb
     &,muls,modetype)
      endif
      if(prec.eq.2) then
        call truncate_sp2hp(sf_c, dimhhpp)
      else if(prec.eq.1) then
        call truncate_sp2bf(sf_c, dimhhpp)
      endif
      END IF
      END IF
      END IF
      END DO
      END DO
      IF ((p3b .le. p4b) .and. (h1b .le. h2b)) THEN
      CALL TCE_SORT_4_mp_s2d(sf_c,df_t,int_mb(k_range+h2b-1)
     &,int_mb(k_range+p4b-1),int_mb(k_range+h1b-1),int_mb(k_range+p3b-1)
     &,4,2,3,1,-1.0d0)
      CALL ADD_HASH_BLOCK(d_c,df_t,dimc,int_mb(k_c_offset),(h2b -
     & 1 + noab * (h1b - 1 + noab * (p4b - noab - 1 + nvab * (p3b - noab
     & - 1)))))
      END IF
      IF ((p3b .le. p4b) .and. (h2b .le. h1b)) THEN
      CALL TCE_SORT_4_mp_s2d(sf_c,df_t,int_mb(k_range+h2b-1)
     &,int_mb(k_range+p4b-1),int_mb(k_range+h1b-1),int_mb(k_range+p3b-1)
     &,4,2,1,3,1.0d0)
      CALL ADD_HASH_BLOCK(d_c,df_t,dimc,int_mb(k_c_offset),(h1b -
     & 1 + noab * (h2b - 1 + noab * (p4b - noab - 1 + nvab * (p3b - noab
     & - 1)))))
      END IF
      IF ((p4b .le. p3b) .and. (h1b .le. h2b)) THEN
      CALL TCE_SORT_4_mp_s2d(sf_c,df_t,int_mb(k_range+h2b-1)
     &,int_mb(k_range+p4b-1),int_mb(k_range+h1b-1),int_mb(k_range+p3b-1)
     &,2,4,3,1,1.0d0)
      CALL ADD_HASH_BLOCK(d_c,df_t,dimc,int_mb(k_c_offset),(h2b -
     & 1 + noab * (h1b - 1 + noab * (p3b - noab - 1 + nvab * (p4b - noab
     & - 1)))))
      END IF
      IF ((p4b .le. p3b) .and. (h2b .le. h1b)) THEN
      CALL TCE_SORT_4_mp_s2d(sf_c,df_t,int_mb(k_range+h2b-1)
     &,int_mb(k_range+p4b-1),int_mb(k_range+h1b-1),int_mb(k_range+p3b-1)
     &,2,4,1,3,-1.0d0)
      CALL ADD_HASH_BLOCK(d_c,df_t,dimc,int_mb(k_c_offset),(h1b -
     & 1 + noab * (h2b - 1 + noab * (p3b - noab - 1 + nvab * (p4b - noab
     & - 1)))))
      END IF
      next = NXTASK(nprocs, 1)
      END IF
      count = count + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      next = NXTASK(-nprocs, 1)
      call GA_SYNC()

      deallocate(sf_a,stat=e_a)
      deallocate(sf_b,stat=e_b)
      deallocate(sf_c,stat=e_c)
      deallocate(df_t,stat=e_t)
      if (e_a.ne.0) call errquit("MA pops a",0,MA_ERR)
      if (e_b.ne.0) call errquit("MA pops b",0,MA_ERR)
      if (e_c.ne.0) call errquit("MA pops c",0,MA_ERR)
      if (e_t.ne.0) call errquit("MA pops t",1,MA_ERR)
      RETURN
      END

      SUBROUTINE ccsd_t2_2_5_mp(d_a,k_a_offset,d_b,k_b_offset,d_c,
     &     k_c_offset, maxh, maxp, prec)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i1 ( h10 p3 h1 h2 )_vt + = 1 * P( 2 ) * Sum ( h7 p9 ) * t ( p3 p9 h1 h7 )_t * i2 ( h7 h10 h2 p9 )_v
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      integer, parameter :: sp = selected_real_kind(6, 37)
      integer, parameter :: dp = selected_real_kind(15, 307)
      INTEGER prec
      INTEGER d_a
      INTEGER k_a_offset
      INTEGER d_b
      INTEGER k_b_offset
      INTEGER d_c
      INTEGER k_c_offset
      INTEGER NXTASK
      INTEGER next
      INTEGER nprocs
      INTEGER count
      INTEGER p3b
      INTEGER h10b
      INTEGER h1b
      INTEGER h2b
      INTEGER dimc
      INTEGER l_cs
      INTEGER k_cs
      INTEGER p9b
      INTEGER h7b
      INTEGER p3b_1
      INTEGER p9b_1
      INTEGER h1b_1
      INTEGER h7b_1
      INTEGER h10b_2
      INTEGER h7b_2
      INTEGER h2b_2
      INTEGER p9b_2
      INTEGER dim_common
      INTEGER dima_sort
      INTEGER dima
      INTEGER dimb_sort
      INTEGER dimb
      INTEGER l_as
      INTEGER k_as
      INTEGER l_a
      INTEGER k_a
      INTEGER l_bs
      INTEGER k_bs
      INTEGER l_b
      INTEGER k_b
      INTEGER l_c
      INTEGER k_c
      INTEGER maxh, maxp, dimhhpp, dimhhhp, dimtemp
      EXTERNAL NXTASK
      real(kind=dp), allocatable :: df_t(:)
      real(kind=sp), allocatable :: sf_a(:)
      real(kind=sp), allocatable :: sf_b(:)
      real(kind=sp), allocatable :: sf_c(:)
      integer :: e_a,e_b,e_c,e_t
      integer :: splita, splitb, muls
      character*1 modetype
      nprocs = GA_NNODES()
      count = 0
      next = NXTASK(nprocs, 1)

      dimhhpp = maxh*maxh*maxp*maxp
      dimhhhp = maxh*maxh*maxh*maxp
      dimtemp = max(dimhhpp, dimhhhp)

      allocate(sf_a(1:dimhhpp),stat=e_a)
      allocate(sf_b(1:dimhhhp),stat=e_b)
      allocate(sf_c(1:dimhhhp),stat=e_c)
      allocate(df_t(1:dimtemp),stat=e_t)
      if (e_a.ne.0) call errquit("MA a",dimhhpp,MA_ERR)
      if (e_b.ne.0) call errquit("MA b",dimhhhp,MA_ERR)
      if (e_c.ne.0) call errquit("MA c",dimhhhp,MA_ERR)
      if (e_t.ne.0) call errquit("MA t",dimtemp,MA_ERR)

      DO p3b = noab+1,noab+nvab
      DO h10b = 1,noab
      DO h1b = 1,noab
      DO h2b = 1,noab
      IF ((.not.restricted).or.(int_mb(k_spin+p3b-1)+int_mb(k_spin+h10b-
     &1)+int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1).ne.8)) THEN
      IF (int_mb(k_spin+p3b-1)+int_mb(k_spin+h10b-1) .eq. int_mb(k_spin+
     &h1b-1)+int_mb(k_spin+h2b-1)) THEN
      IF (ieor(int_mb(k_sym+p3b-1),ieor(int_mb(k_sym+h10b-1),ieor(int_mb
     &(k_sym+h1b-1),int_mb(k_sym+h2b-1)))) .eq. ieor(irrep_v,irrep_t)) T
     &HEN
      IF (next.eq.count) THEN
      dimc = int_mb(k_range+p3b-1) * int_mb(k_range+h10b-1) * int_mb(k_r
     &ange+h1b-1) * int_mb(k_range+h2b-1)
      CALL SFILL(dimc,0.0,sf_c,1)
      DO p9b = noab+1,noab+nvab
      DO h7b = 1,noab
      IF (int_mb(k_spin+p3b-1)+int_mb(k_spin+p9b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+h7b-1)) THEN
      IF (ieor(int_mb(k_sym+p3b-1),ieor(int_mb(k_sym+p9b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+h7b-1)))) .eq. irrep_t) THEN
      CALL TCE_RESTRICTED_4(p3b,p9b,h1b,h7b,p3b_1,p9b_1,h1b_1,h7b_1)
      CALL TCE_RESTRICTED_4(h10b,h7b,h2b,p9b,h10b_2,h7b_2,h2b_2,p9b_2)
      dim_common = int_mb(k_range+p9b-1) * int_mb(k_range+h7b-1)
      dima_sort = int_mb(k_range+p3b-1) * int_mb(k_range+h1b-1)
      dima = dim_common * dima_sort
      dimb_sort = int_mb(k_range+h10b-1) * int_mb(k_range+h2b-1)
      dimb = dim_common * dimb_sort
      IF ((dima .gt. 0) .and. (dimb .gt. 0)) THEN
      IF ((p9b .lt. p3b) .and. (h7b .lt. h1b)) THEN
      CALL GET_HASH_BLOCK(d_a,df_t,dima,int_mb(k_a_offset),(h1b_1
     & - 1 + noab * (h7b_1 - 1 + noab * (p3b_1 - noab - 1 + nvab * (p9b_
     &1 - noab - 1)))))
      CALL TCE_SORT_4_mp_d2s(df_t,sf_a,int_mb(k_range+p9b-1)
     &,int_mb(k_range+p3b-1),int_mb(k_range+h7b-1),int_mb(k_range+h1b-1)
     &,4,2,3,1,1.0d0)
      END IF
      IF ((p9b .lt. p3b) .and. (h1b .le. h7b)) THEN
      CALL GET_HASH_BLOCK(d_a,df_t,dima,int_mb(k_a_offset),(h7b_1
     & - 1 + noab * (h1b_1 - 1 + noab * (p3b_1 - noab - 1 + nvab * (p9b_
     &1 - noab - 1)))))
      CALL TCE_SORT_4_mp_d2s(df_t,sf_a,int_mb(k_range+p9b-1)
     &,int_mb(k_range+p3b-1),int_mb(k_range+h1b-1),int_mb(k_range+h7b-1)
     &,3,2,4,1,-1.0d0)
      END IF
      IF ((p3b .le. p9b) .and. (h7b .lt. h1b)) THEN
      CALL GET_HASH_BLOCK(d_a,df_t,dima,int_mb(k_a_offset),(h1b_1
     & - 1 + noab * (h7b_1 - 1 + noab * (p9b_1 - noab - 1 + nvab * (p3b_
     &1 - noab - 1)))))
      CALL TCE_SORT_4_mp_d2s(df_t,sf_a,int_mb(k_range+p3b-1)
     &,int_mb(k_range+p9b-1),int_mb(k_range+h7b-1),int_mb(k_range+h1b-1)
     &,4,1,3,2,-1.0d0)
      END IF
      IF ((p3b .le. p9b) .and. (h1b .le. h7b)) THEN
      CALL GET_HASH_BLOCK(d_a,df_t,dima,int_mb(k_a_offset),(h7b_1
     & - 1 + noab * (h1b_1 - 1 + noab * (p9b_1 - noab - 1 + nvab * (p3b_
     &1 - noab - 1)))))
      CALL TCE_SORT_4_mp_d2s(df_t,sf_a,int_mb(k_range+p3b-1)
     &,int_mb(k_range+p9b-1),int_mb(k_range+h1b-1),int_mb(k_range+h7b-1)
     &,3,1,4,2,1.0d0)
      END IF
      IF ((h7b .le. h10b)) THEN
      CALL GET_HASH_BLOCK(d_b,df_t,dimb,int_mb(k_b_offset),(p9b_2
     & - noab - 1 + nvab * (h2b_2 - 1 + noab * (h10b_2 - 1 + noab * (h7b
     &_2 - 1)))))
      CALL TCE_SORT_4_mp_d2s(df_t,sf_b,int_mb(k_range+h7b-1)
     &,int_mb(k_range+h10b-1),int_mb(k_range+h2b-1),int_mb(k_range+p9b-1
     &),3,2,1,4,1.0d0)
      END IF
      IF ((h10b .lt. h7b)) THEN
      CALL GET_HASH_BLOCK(d_b,df_t,dimb,int_mb(k_b_offset),(p9b_2
     & - noab - 1 + nvab * (h2b_2 - 1 + noab * (h7b_2 - 1 + noab * (h10b
     &_2 - 1)))))
      CALL TCE_SORT_4_mp_d2s(df_t,sf_b,int_mb(k_range+h10b-1
     &),int_mb(k_range+h7b-1),int_mb(k_range+h2b-1),int_mb(k_range+p9b-1
     &),3,1,2,4,-1.0d0)
      END IF
      if(prec.eq.2) then
         call truncate_sp2hp(sf_a, dimhhpp)
         call truncate_sp2hp(sf_b, dimhhhp)
      else if(prec.eq.1) then
         call truncate_sp2bf(sf_a, dimhhpp)
         call truncate_sp2bf(sf_b, dimhhhp)
      endif
!     CALL SGEMM('T','N',dima_sort,dimb_sort,dim_common,1.0,sf_a
!    &,dim_common,sf_b,dim_common,1.0,sf_c,dima_sort)
!     prec = 1: BF16x1
!     prec = 2: FP16x1
!     prec = 3: FP32
!     prec = 4: FP64: I have no idea how this is done...
!     prec = 5: BF16x2
!     prec = 6: BF16x3
!     prec = 7: FP16x2
!     prec = 8: FP16x3
      if ( (prec .eq. 1) .or. (prec .eq. 5) .or. (prec .eq. 6) ) then
         modetype = 'B'
      else if ( (prec.eq.2) .or. (prec.eq.7) .or. (prec .eq. 8) ) then
         modetype = 'F'
      endif
      if ( (prec .eq. 5) .or. (prec .eq. 7) ) then
         splita = 2
         splitb = 2
         muls = 3
      endif
      if ( (prec .eq. 6) .or. (prec .eq. 8) ) then
         splita = 3
         splitb = 3
         muls = 6
      endif
      if ( prec .eq. 3 ) then
         CALL SGEMM('T','N',dima_sort,dimb_sort,dim_common,1.0,sf_a
     &,dim_common,sf_b,dim_common,1.0,sf_c, dima_sort)
      else if ( (prec .ge. 5) .and. (prec .le. 8) ) then
         call sgemmreplacement('T','N',dima_sort,dimb_sort,dim_common,1.0
     &,sf_a,dim_common,sf_b,dim_common,1.0,sf_c,dima_sort,splita,splitb
     &,muls,modetype)
      endif
      if(prec.eq.2) then
         call truncate_sp2hp(sf_c, dimhhhp)
      else if(prec.eq.1) then
         call truncate_sp2bf(sf_c, dimhhhp)
      endif
      END IF
      END IF
      END IF
      END DO
      END DO
      IF ((h1b .le. h2b)) THEN
      CALL TCE_SORT_4_mp_s2d(sf_c,df_t,int_mb(k_range+h2b-1)
     &,int_mb(k_range+h10b-1),int_mb(k_range+h1b-1),int_mb(k_range+p3b-1
     &),4,2,3,1,1.0d0)
      CALL ADD_HASH_BLOCK(d_c,df_t,dimc,int_mb(k_c_offset),(h2b -
     & 1 + noab * (h1b - 1 + noab * (h10b - 1 + noab * (p3b - noab - 1))
     &)))
      END IF
      IF ((h2b .le. h1b)) THEN
      CALL TCE_SORT_4_mp_s2d(sf_c,df_t,int_mb(k_range+h2b-1)
     &,int_mb(k_range+h10b-1),int_mb(k_range+h1b-1),int_mb(k_range+p3b-1
     &),4,2,1,3,-1.0d0)
      CALL ADD_HASH_BLOCK(d_c,df_t,dimc,int_mb(k_c_offset),(h1b -
     & 1 + noab * (h2b - 1 + noab * (h10b - 1 + noab * (p3b - noab - 1))
     &)))
      END IF
      next = NXTASK(nprocs, 1)
      END IF
      count = count + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      next = NXTASK(-nprocs, 1)
      call GA_SYNC()

      deallocate(sf_a,stat=e_a)
      deallocate(sf_b,stat=e_b)
      deallocate(sf_c,stat=e_c)
      deallocate(df_t,stat=e_t)
      if (e_a.ne.0) call errquit("MA pops a",0,MA_ERR)
      if (e_b.ne.0) call errquit("MA pops b",0,MA_ERR)
      if (e_c.ne.0) call errquit("MA pops c",0,MA_ERR)
      if (e_t.ne.0) call errquit("MA pops t",1,MA_ERR)
      RETURN
      END

      SUBROUTINE ccsd_t2_2_6_mp(d_a,k_a_offset,d_b,k_b_offset,d_c,
     &     k_c_offset, maxh, maxp, prec)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i1 ( h10 p3 h1 h2 )_vt + = 1/2 * Sum ( p5 p6 ) * t ( p5 p6 h1 h2 )_t * v ( h10 p3 p5 p6 )_v
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      integer, parameter :: sp = selected_real_kind(6, 37)
      integer, parameter :: dp = selected_real_kind(15, 307)
      INTEGER prec
      INTEGER d_a
      INTEGER k_a_offset
      INTEGER d_b
      INTEGER k_b_offset
      INTEGER d_c
      INTEGER k_c_offset
      INTEGER NXTASK
      INTEGER next
      INTEGER nprocs
      INTEGER count
      INTEGER p3b
      INTEGER h10b
      INTEGER h1b
      INTEGER h2b
      INTEGER dimc
      INTEGER l_cs
      INTEGER k_cs
      INTEGER p5b
      INTEGER p6b
      INTEGER p5b_1
      INTEGER p6b_1
      INTEGER h1b_1
      INTEGER h2b_1
      INTEGER p3b_2
      INTEGER h10b_2
      INTEGER p5b_2
      INTEGER p6b_2
      INTEGER dim_common
      INTEGER dima_sort
      INTEGER dima
      INTEGER dimb_sort
      INTEGER dimb
      INTEGER l_as
      INTEGER k_as
      INTEGER l_a
      INTEGER k_a
      INTEGER l_bs
      INTEGER k_bs
      INTEGER l_b
      INTEGER k_b
      INTEGER l_c
      INTEGER k_c
      integer p5b_in,p6b_in
      DOUBLE PRECISION FACTORIAL
      INTEGER maxh, maxp, dimhhpp, dimhppp, dimhhhp, dimtemp
      EXTERNAL NXTASK
      EXTERNAL FACTORIAL
      real(kind=dp), allocatable :: df_t(:)
      real(kind=sp), allocatable :: sf_a(:)
      real(kind=sp), allocatable :: sf_b(:)
      real(kind=sp), allocatable :: sf_c(:)
      integer :: e_a,e_b,e_c,e_t
      real(kind=sp) alpha
      integer :: splita, splitb, muls
      character*1 modetype
      nprocs = GA_NNODES()
      count = 0
      next = NXTASK(nprocs, 1)

      dimhhpp = maxh*maxh*maxp*maxp
      dimhppp = maxh*maxp*maxp*maxp
      dimhhhp = maxh*maxh*maxh*maxp
      dimtemp = max(dimhhhp, dimhppp)

      allocate(sf_a(1:dimhhpp),stat=e_a)
      allocate(sf_b(1:dimhppp),stat=e_b)
      allocate(sf_c(1:dimhhhp),stat=e_c)
      allocate(df_t(1:dimtemp),stat=e_t)
      if (e_a.ne.0) call errquit("MA a",dimhhpp,MA_ERR)
      if (e_b.ne.0) call errquit("MA b",dimhhhp,MA_ERR)
      if (e_c.ne.0) call errquit("MA c",dimhhhp,MA_ERR)
      if (e_t.ne.0) call errquit("MA t",dimtemp,MA_ERR)

      DO p3b = noab+1,noab+nvab
      DO h10b = 1,noab
      DO h1b = 1,noab
      DO h2b = h1b,noab
      IF ((.not.restricted).or.(int_mb(k_spin+p3b-1)+int_mb(k_spin+h10b-
     &1)+int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1).ne.8)) THEN
      IF (int_mb(k_spin+p3b-1)+int_mb(k_spin+h10b-1) .eq. int_mb(k_spin+
     &h1b-1)+int_mb(k_spin+h2b-1)) THEN
      IF (ieor(int_mb(k_sym+p3b-1),ieor(int_mb(k_sym+h10b-1),ieor(int_mb
     &(k_sym+h1b-1),int_mb(k_sym+h2b-1)))) .eq. ieor(irrep_v,irrep_t)) T
     &HEN
      IF (next.eq.count) THEN
      dimc = int_mb(k_range+p3b-1) * int_mb(k_range+h10b-1) * int_mb(k_r
     &ange+h1b-1) * int_mb(k_range+h2b-1)
      CALL SFILL(dimc,0.0,sf_c,1)
#if 0
      DO p5b = noab+1,noab+nvab
      DO p6b = p5b,noab+nvab
#else
      DO p5b_in =ga_nodeid(),ga_nodeid()+nvab-1
         p5b=mod(p5b_in,nvab)+noab+1
         DO p6b_in=ga_nodeid(),ga_nodeid()+nvab+noab-p5b
            p6b=mod(p6b_in,noab+nvab-p5b+1)+p5b
#endif
      IF (int_mb(k_spin+p5b-1)+int_mb(k_spin+p6b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+h2b-1)) THEN
      IF (ieor(int_mb(k_sym+p5b-1),ieor(int_mb(k_sym+p6b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+h2b-1)))) .eq. irrep_t) THEN
      CALL TCE_RESTRICTED_4(p5b,p6b,h1b,h2b,p5b_1,p6b_1,h1b_1,h2b_1)
      CALL TCE_RESTRICTED_4(p3b,h10b,p5b,p6b,p3b_2,h10b_2,p5b_2,p6b_2)
      dim_common = int_mb(k_range+p5b-1) * int_mb(k_range+p6b-1)
      dima_sort = int_mb(k_range+h1b-1) * int_mb(k_range+h2b-1)
      dima = dim_common * dima_sort
      dimb_sort = int_mb(k_range+p3b-1) * int_mb(k_range+h10b-1)
      dimb = dim_common * dimb_sort
      IF ((dima .gt. 0) .and. (dimb .gt. 0)) THEN
      CALL GET_HASH_BLOCK(d_a,df_t,dima,int_mb(k_a_offset),(h2b_1
     & - 1 + noab * (h1b_1 - 1 + noab * (p6b_1 - noab - 1 + nvab * (p5b_
     &1 - noab - 1)))))
      CALL TCE_SORT_4_mp_d2s(df_t,sf_a,int_mb(k_range+p5b-1)
     &,int_mb(k_range+p6b-1),int_mb(k_range+h1b-1),int_mb(k_range+h2b-1)
     &,4,3,2,1,1.0d0)
      IF ((h10b .le. p3b)) THEN
      if(.not.intorb) then
      CALL GET_HASH_BLOCK(d_b,df_t,dimb,int_mb(k_b_offset),(p6b_2
     & - 1 + (noab+nvab) * (p5b_2 - 1 + (noab+nvab) * (p3b_2 - 1 + (noab
     &+nvab) * (h10b_2 - 1)))))
      else
      CALL GET_HASH_BLOCK_I(d_b,df_t,dimb,int_mb(k_b_offset),
     &(p6b_2
     & - 1 + (noab+nvab) * (p5b_2 - 1 + (noab+nvab) * (p3b_2 - 1 + (noab
     &+nvab) * (h10b_2 - 1)))),p6b_2,p5b_2,p3b_2,h10b_2)
      end if
      CALL TCE_SORT_4_mp_d2s(df_t,sf_b,int_mb(k_range+h10b-1
     &),int_mb(k_range+p3b-1),int_mb(k_range+p5b-1),int_mb(k_range+p6b-1
     &),1,2,4,3,1.0d0)
      END IF
      IF (p5b .eq. p6b) THEN
        alpha = 1.0
      ELSE
         alpha = 2.0
      END IF
      if(prec.eq.2) then
         call truncate_sp2hp(sf_a, dimhhpp)
         call truncate_sp2hp(sf_b, dimhhhp)
      else if(prec.eq.1) then
         call truncate_sp2bf(sf_a, dimhhpp)
         call truncate_sp2bf(sf_b, dimhhhp)
      endif
!     CALL SGEMM('T','N',dima_sort,dimb_sort,dim_common,alpha
!    &,sf_a,dim_common,sf_b,dim_common,1.0, sf_c, dima_sort)
!     prec = 1: BF16x1
!     prec = 2: FP16x1
!     prec = 3: FP32
!     prec = 4: FP64: I have no idea how this is done...
!     prec = 5: BF16x2
!     prec = 6: BF16x3
!     prec = 7: FP16x2
!     prec = 8: FP16x3
      if ( (prec .eq. 1) .or. (prec .eq. 5) .or. (prec .eq. 6) ) then
         modetype = 'B'
      else if ( (prec.eq.2) .or. (prec.eq.7) .or. (prec .eq. 8) ) then
         modetype = 'F'
      endif
      if ( (prec .eq. 5) .or. (prec .eq. 7) ) then
         splita = 2
         splitb = 2
         muls = 3
      endif
      if ( (prec .eq. 6) .or. (prec .eq. 8) ) then
         splita = 3
         splitb = 3
         muls = 6
      endif
      if ( prec .eq. 3 ) then
         CALL SGEMM('T','N',dima_sort,dimb_sort,dim_common,1.0,sf_a
     &,dim_common,sf_b,dim_common,1.0,sf_c, dima_sort)
      else if ( (prec .ge. 5) .and. (prec .le. 8) ) then
         call sgemmreplacement('T','N',dima_sort,dimb_sort,dim_common,1.0
     &,sf_a,dim_common,sf_b,dim_common,1.0,sf_c,dima_sort,splita,splitb
     &,muls,modetype)
      endif
      if(prec.eq.2) then
         call truncate_sp2hp(sf_c, dimhhhp)
      else if(prec.eq.1) then
         call truncate_sp2bf(sf_c, dimhhhp)
      endif
      END IF
      END IF
      END IF
      END DO
      END DO
      CALL TCE_SORT_4_mp_s2d(sf_c,df_t,int_mb(k_range+h10b-1
     &),int_mb(k_range+p3b-1),int_mb(k_range+h2b-1),int_mb(k_range+h1b-1
     &),2,1,4,3,1.0d0/2.0d0)
      CALL ADD_HASH_BLOCK(d_c,df_t,dimc,int_mb(k_c_offset),(h2b -
     & 1 + noab * (h1b - 1 + noab * (h10b - 1 + noab * (p3b - noab - 1))
     &)))
      next = NXTASK(nprocs, 1)
      END IF
      count = count + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      next = NXTASK(-nprocs, 1)
      call GA_SYNC()

      deallocate(sf_a,stat=e_a)
      deallocate(sf_b,stat=e_b)
      deallocate(sf_c,stat=e_c)
      deallocate(df_t,stat=e_t)
      if (e_a.ne.0) call errquit("MA pops a",0,MA_ERR)
      if (e_b.ne.0) call errquit("MA pops b",0,MA_ERR)
      if (e_c.ne.0) call errquit("MA pops c",0,MA_ERR)
      if (e_t.ne.0) call errquit("MA pops t",1,MA_ERR)
      RETURN
      END

      SUBROUTINE ccsd_t2_8_mp(d_a,k_a_offset,
     &                             d_b,k_b_offset,
     &                             d_c,k_c_offset,
     &                             maxh,maxp,prec)
!     $Id: ccsd_t2.F 27404 2015-08-24 14:20:43Z jhammond $
!     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
!     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
!     i0 ( p3 p4 h1 h2 )_vt + = 1/2 * Sum ( p5 p6 ) * t ( p5 p6 h1 h2 )_t * v ( p3 p4 p5 p6 )_v
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      integer, parameter :: sp = selected_real_kind(6, 37)
      integer, parameter :: dp = selected_real_kind(15, 307)
      INTEGER prec
      INTEGER d_a,d_b,d_c
      INTEGER k_a_offset,k_b_offset,k_c_offset
      INTEGER maxh,maxp,dimhhpp,dimpppp,dimtemp
      INTEGER next,nprocs,count
      INTEGER p5b,p6b,p3b,p4b,h1b,h2b
      INTEGER p5b_1,p6b_1,h1b_1,h2b_1
      INTEGER p3b_2,p4b_2,p5b_2,p6b_2
      INTEGER dima,dimb,dimc,dim_common,dima_sort,dimb_sort
      real(kind=dp), allocatable :: df_t(:)
      real(kind=sp), allocatable :: sf_a(:)
      real(kind=sp), allocatable :: sf_b(:)
      real(kind=sp), allocatable :: sf_c(:)
      integer :: e_a,e_b,e_c,e_t
      real(kind=sp) alpha
      integer p5b_in,p6b_in
      INTEGER NXTASK
      EXTERNAL NXTASK
      integer :: splita, splitb, muls
      character*1 modetype
      nprocs = GA_NNODES()
      count = 0
      next = NXTASK(nprocs, 1)

      dimhhpp = maxh*maxh*maxp*maxp
      dimpppp = maxp*maxp*maxp*maxp
      dimtemp = max(dimhhpp, dimpppp)

      allocate(sf_a(1:dimhhpp),stat=e_a)
      allocate(sf_b(1:dimpppp),stat=e_b)
      allocate(sf_c(1:dimhhpp),stat=e_c)
      allocate(df_t(1:dimtemp),stat=e_t)
      if (e_a.ne.0) call errquit("MA a",dimhhpp,MA_ERR)
      if (e_b.ne.0) call errquit("MA b",dimpppp,MA_ERR)
      if (e_c.ne.0) call errquit("MA c",dimhhpp,MA_ERR)
      if (e_t.ne.0) call errquit("MA t",dimtemp,MA_ERR)

      DO p3b = noab+1,noab+nvab
       DO p4b = p3b,noab+nvab
        DO h1b = 1,noab
         DO h2b = h1b,noab
          IF ((.not.restricted).or.
     &        ( int_mb(k_spin+p3b-1)+int_mb(k_spin+p4b-1)
     &         +int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1).ne.8)) THEN
           IF (int_mb(k_spin+p3b-1)+int_mb(k_spin+p4b-1) .eq.
     &         int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1)) THEN
            IF (ieor(int_mb(k_sym+p3b-1),ieor(int_mb(k_sym+p4b-1),
     &          ieor(int_mb(k_sym+h1b-1),int_mb(k_sym+h2b-1))))
     &                 .eq. ieor(irrep_v,irrep_t)) THEN
             IF (next.eq.count) THEN
              dima_sort = int_mb(k_range+h1b-1)
     &                  * int_mb(k_range+h2b-1)
              dimb_sort = int_mb(k_range+p3b-1)
     &                  * int_mb(k_range+p4b-1)
              dimc = int_mb(k_range+p3b-1) * int_mb(k_range+p4b-1)
     &             * int_mb(k_range+h1b-1) * int_mb(k_range+h2b-1)
              CALL SFILL(dimc,0.0,sf_c,1)
#if 0
              DO p5b = noab+1,noab+nvab
               DO p6b = p5b,noab+nvab
#else
              DO p5b_in =ga_nodeid(),ga_nodeid()+nvab-1
                 p5b=mod(p5b_in,nvab)+noab+1
               DO p6b_in=ga_nodeid(),ga_nodeid()+nvab+noab-p5b
                  p6b=mod(p6b_in,noab+nvab-p5b+1)+p5b
#endif
                IF (int_mb(k_spin+p5b-1)+int_mb(k_spin+p6b-1) .eq.
     &              int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1)) THEN
                 IF (ieor(int_mb(k_sym+p5b-1),ieor(int_mb(k_sym+p6b-1),
     &               ieor(int_mb(k_sym+h1b-1),int_mb(k_sym+h2b-1))))
     &                      .eq. irrep_t) THEN
                  CALL TCE_RESTRICTED_4(p5b,p6b,h1b,h2b,
     &                                  p5b_1,p6b_1,h1b_1,h2b_1)
                  CALL TCE_RESTRICTED_4(p3b,p4b,p5b,p6b,
     &                                  p3b_2,p4b_2,p5b_2,p6b_2)
                  dim_common = int_mb(k_range+p5b-1)
     &                       * int_mb(k_range+p6b-1)
                  dima = dim_common * dima_sort
                  dimb = dim_common * dimb_sort
                  IF ((dima .gt. 0) .and. (dimb .gt. 0)) THEN
                   CALL GET_HASH_BLOCK(d_a,df_t,dima,
     &                  int_mb(k_a_offset),(h2b_1-1+noab*(h1b_1-1+noab*
     &                  (p6b_1-noab-1+nvab*(p5b_1-noab-1)))))
                   CALL tce_sort_4_mp_d2s(df_t,sf_a,
     &                  int_mb(k_range+p5b-1),int_mb(k_range+p6b-1),
     &                  int_mb(k_range+h1b-1),int_mb(k_range+h2b-1),
     &                  4,3,2,1,1.0d0)
                   if(.not.intorb) then
                    CALL GET_HASH_BLOCK(d_b,df_t,dimb,
     &                   int_mb(k_b_offset),(p6b_2-1+(noab+nvab)*
     &                   (p5b_2-1+(noab+nvab)*(p4b_2-1+(noab+nvab)*
     &                   (p3b_2-1)))))
                   else
                    CALL GET_HASH_BLOCK_I(d_b,df_t,dimb,
     &                   int_mb(k_b_offset),(p6b_2-1+(noab+nvab)*
     &                   (p5b_2-1+(noab+nvab)*(p4b_2-1+(noab+nvab)*
     &                   (p3b_2-1)))),p6b_2,p5b_2,p4b_2,p3b_2)
                   end if
                   CALL tce_sort_4_mp_d2s(df_t,sf_b,
     &                  int_mb(k_range+p3b-1),int_mb(k_range+p4b-1),
     &                  int_mb(k_range+p5b-1),int_mb(k_range+p6b-1),
     &                  2,1,4,3,1.0d0)
                   if (p5b .eq. p6b) then
                    alpha = 1.0
                   else
                    alpha = 2.0
                   end if
                   if(prec.eq.2) then
                      call truncate_sp2hp(sf_a, dimhhpp)
                      call truncate_sp2hp(sf_b, dimpppp)
                   else if(prec.eq.1) then
                      call truncate_sp2bf(sf_a, dimhhpp)
                      call truncate_sp2bf(sf_b, dimpppp)
                   endif
!                  CALL SGEMM('T','N',dima_sort,dimb_sort,dim_common,
!    &                        alpha,sf_a,dim_common,sf_b,
!    &                        dim_common,1.0,sf_c,dima_sort)
!                  prec = 1: BF16x1
!                  prec = 2: FP16x1
!                  prec = 3: FP32
!                  prec = 4: FP64: I have no idea how this is done...
!                  prec = 5: BF16x2
!                  prec = 6: BF16x3
!                  prec = 7: FP16x2
!                  prec = 8: FP16x3
                   if ( (prec .eq. 1) .or. (prec .eq. 5) .or.
     &                  (prec .eq. 6) ) then
                      modetype = 'B'
                   else if ( (prec.eq.2) .or. (prec.eq.7) .or.
     &                  (prec .eq. 8) ) then
                      modetype = 'F'
                   endif
                   if ( (prec .eq. 5) .or. (prec .eq. 7) ) then
                      splita = 2
                      splitb = 2
                      muls = 3
                   endif
                   if ( (prec .eq. 6) .or. (prec .eq. 8) ) then
                      splita = 3
                      splitb = 3
                      muls = 6
                   endif
                   if ( prec .eq. 3 ) then
                   CALL SGEMM('T','N',dima_sort,dimb_sort,dim_common,
     &                        alpha,sf_a,dim_common,sf_b,
     &                        dim_common,1.0,sf_c,dima_sort)
                   else if ( (prec .ge. 5) .and. (prec .le. 8) ) then
                   CALL sgemmreplacement('T','N',dima_sort,dimb_sort,
     &                        dim_common,alpha,sf_a,dim_common,sf_b,
     &                        dim_common,1.0,sf_c,dima_sort)
                   endif
                   if(prec.eq.2) then
                      call truncate_sp2hp(sf_c, dimhhpp)
                   else if(prec.eq.1) then
                      call truncate_sp2bf(sf_c, dimhhpp)
                   endif
                  END IF
                 END IF
                END IF
               END DO
              END DO
              CALL tce_sort_4_mp_s2d(sf_c,df_t,
     &             int_mb(k_range+p4b-1),int_mb(k_range+p3b-1),
     &             int_mb(k_range+h2b-1),int_mb(k_range+h1b-1),
     &             2,1,4,3,0.5d0)
              CALL ADD_HASH_BLOCK(d_c,df_t,dimc,
     &             int_mb(k_c_offset),(h2b-1+noab*(h1b-1+noab*
     &             (p4b-noab-1+nvab*(p3b-noab-1)))))
              next = NXTASK(nprocs, 1)
             END IF
             count = count + 1
            END IF
           END IF
          END IF
         END DO
        END DO
       END DO
      END DO
      next = NXTASK(-nprocs, 1)
      call GA_SYNC()

      deallocate(sf_a,stat=e_a)
      deallocate(sf_b,stat=e_b)
      deallocate(sf_c,stat=e_c)
      deallocate(df_t,stat=e_t)
      if (e_a.ne.0) call errquit("MA pops a",0,MA_ERR)
      if (e_b.ne.0) call errquit("MA pops b",0,MA_ERR)
      if (e_c.ne.0) call errquit("MA pops c",0,MA_ERR)
      if (e_t.ne.0) call errquit("MA pops t",1,MA_ERR)
      RETURN
      END

      SUBROUTINE ccsd_t2_6_3_mp(d_a,k_a_offset,d_b,k_b_offset,d_c,
     &     k_c_offset, maxh, maxp, prec)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i1 ( h9 h11 h1 h2 )_vt + = -1/2 * Sum ( p5 p6 ) * t ( p5 p6 h1 h2 )_t * v ( h9 h11 p5 p6 )_v
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      integer, parameter :: sp = selected_real_kind(6, 37)
      integer, parameter :: dp = selected_real_kind(15, 307)
      INTEGER prec
      INTEGER d_a
      INTEGER k_a_offset
      INTEGER d_b
      INTEGER k_b_offset
      INTEGER d_c
      INTEGER k_c_offset
      INTEGER NXTASK
      INTEGER next
      INTEGER nprocs
      INTEGER count
      INTEGER h9b
      INTEGER h11b
      INTEGER h1b
      INTEGER h2b
      INTEGER dimc
      INTEGER l_cs
      INTEGER k_cs
      INTEGER p5b
      INTEGER p6b
      INTEGER p5b_1
      INTEGER p6b_1
      INTEGER h1b_1
      INTEGER h2b_1
      INTEGER h9b_2
      INTEGER h11b_2
      INTEGER p5b_2
      INTEGER p6b_2
      INTEGER dim_common
      INTEGER dima_sort
      INTEGER dima
      INTEGER dimb_sort
      INTEGER dimb
      INTEGER l_as
      INTEGER k_as
      INTEGER l_a
      INTEGER k_a
      INTEGER l_bs
      INTEGER k_bs
      INTEGER l_b
      INTEGER k_b
      INTEGER l_c
      INTEGER k_c
      DOUBLE PRECISION FACTORIAL
      INTEGER maxh, maxp, dimhhpp, dimhhhh, dimtemp
      EXTERNAL NXTASK
      EXTERNAL FACTORIAL
      real(kind=dp), allocatable :: df_t(:)
      real(kind=sp), allocatable :: sf_a(:)
      real(kind=sp), allocatable :: sf_b(:)
      real(kind=sp), allocatable :: sf_c(:)
      integer :: e_a,e_b,e_c,e_t
      real(kind=sp) alpha
      integer :: splita, splitb, muls
      character*1 modetype
      nprocs = GA_NNODES()
      count = 0
      next = NXTASK(nprocs, 1)

      dimhhpp = maxh*maxh*maxp*maxp
      dimhhhh = maxh*maxh*maxh*maxh
      dimtemp = max(dimhhpp, dimhhhh)

      allocate(sf_a(1:dimhhpp),stat=e_a)
      allocate(sf_b(1:dimhhpp),stat=e_b)
      allocate(sf_c(1:dimhhhh),stat=e_c)
      allocate(df_t(1:dimtemp),stat=e_t)
      if (e_a.ne.0) call errquit("MA a",dimhhpp,MA_ERR)
      if (e_b.ne.0) call errquit("MA b",dimhhpp,MA_ERR)
      if (e_c.ne.0) call errquit("MA c",dimhhhh,MA_ERR)
      if (e_t.ne.0) call errquit("MA t",dimtemp,MA_ERR)

      DO h9b = 1,noab
      DO h11b = h9b,noab
      DO h1b = 1,noab
      DO h2b = h1b,noab
      IF ((.not.restricted).or.(int_mb(k_spin+h9b-1)+int_mb(k_spin+h11b-
     &1)+int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1).ne.8)) THEN
      IF (int_mb(k_spin+h9b-1)+int_mb(k_spin+h11b-1) .eq. int_mb(k_spin+
     &h1b-1)+int_mb(k_spin+h2b-1)) THEN
      IF (ieor(int_mb(k_sym+h9b-1),ieor(int_mb(k_sym+h11b-1),ieor(int_mb
     &(k_sym+h1b-1),int_mb(k_sym+h2b-1)))) .eq. ieor(irrep_v,irrep_t)) T
     &HEN
      IF (next.eq.count) THEN
      dimc = int_mb(k_range+h9b-1) * int_mb(k_range+h11b-1) * int_mb(k_r
     &ange+h1b-1) * int_mb(k_range+h2b-1)
      CALL SFILL(dimc,0.0,sf_c,1)
      DO p5b = noab+1,noab+nvab
      DO p6b = p5b,noab+nvab
      IF (int_mb(k_spin+p5b-1)+int_mb(k_spin+p6b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+h2b-1)) THEN
      IF (ieor(int_mb(k_sym+p5b-1),ieor(int_mb(k_sym+p6b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+h2b-1)))) .eq. irrep_t) THEN
      CALL TCE_RESTRICTED_4(p5b,p6b,h1b,h2b,p5b_1,p6b_1,h1b_1,h2b_1)
      CALL TCE_RESTRICTED_4(h9b,h11b,p5b,p6b,h9b_2,h11b_2,p5b_2,p6b_2)
      dim_common = int_mb(k_range+p5b-1) * int_mb(k_range+p6b-1)
      dima_sort = int_mb(k_range+h1b-1) * int_mb(k_range+h2b-1)
      dima = dim_common * dima_sort
      dimb_sort = int_mb(k_range+h9b-1) * int_mb(k_range+h11b-1)
      dimb = dim_common * dimb_sort
      IF ((dima .gt. 0) .and. (dimb .gt. 0)) THEN
      CALL GET_HASH_BLOCK(d_a,df_t,dima,int_mb(k_a_offset),(h2b_1
     & - 1 + noab * (h1b_1 - 1 + noab * (p6b_1 - noab - 1 + nvab * (p5b_
     &1 - noab - 1)))))
      CALL TCE_SORT_4_mp_d2s(df_t,sf_a,int_mb(k_range+p5b-1)
     &,int_mb(k_range+p6b-1),int_mb(k_range+h1b-1),int_mb(k_range+h2b-1)
     &,4,3,2,1,1.0d0)
      if(.not.intorb) then
      CALL GET_HASH_BLOCK(d_b,df_t,dimb,int_mb(k_b_offset),(p6b_2
     & - 1 + (noab+nvab) * (p5b_2 - 1 + (noab+nvab) * (h11b_2 - 1 + (noa
     &b+nvab) * (h9b_2 - 1)))))
      else
      CALL GET_HASH_BLOCK_I(d_b,df_t,dimb,int_mb(k_b_offset),
     &(p6b_2
     & - 1 + (noab+nvab) * (p5b_2 - 1 + (noab+nvab) * (h11b_2 - 1 + (noa
     &b+nvab) * (h9b_2 - 1)))),p6b_2,p5b_2,h11b_2,h9b_2)
      end if
      CALL TCE_SORT_4_mp_d2s(df_t,sf_b,int_mb(k_range+h9b-1)
     &,int_mb(k_range+h11b-1),int_mb(k_range+p5b-1),int_mb(k_range+p6b-1
     &),2,1,4,3,1.0d0)
      IF (p5b .eq. p6b) THEN
         alpha = 1.0
      ELSE
         alpha = 2.0
      END IF
      if(prec.eq.2) then
         call truncate_sp2hp(sf_a, dimhhpp)
         call truncate_sp2hp(sf_b, dimhhpp)
      else if(prec.eq.1) then
         call truncate_sp2bf(sf_a, dimhhpp)
         call truncate_sp2bf(sf_b, dimhhpp)
      endif
!     CALL SGEMM('T','N',dima_sort,dimb_sort,dim_common,alpha
!    &,sf_a,dim_common,sf_b,dim_common,1.0,sf_c,dima_sort)
!     prec = 1: BF16x1
!     prec = 2: FP16x1
!     prec = 3: FP32
!     prec = 4: FP64: I have no idea how this is done...
!     prec = 5: BF16x2
!     prec = 6: BF16x3
!     prec = 7: FP16x2
!     prec = 8: FP16x3
      if ( (prec .eq. 1) .or. (prec .eq. 5) .or. (prec .eq. 6) ) then
         modetype = 'B'
      else if ( (prec.eq.2) .or. (prec.eq.7) .or. (prec .eq. 8) ) then
         modetype = 'F'
      endif
      if ( (prec .eq. 5) .or. (prec .eq. 7) ) then
         splita = 2
         splitb = 2
         muls = 3
      endif
      if ( (prec .eq. 6) .or. (prec .eq. 8) ) then
         splita = 3
         splitb = 3
         muls = 6
      endif
      if ( prec .eq. 3 ) then
         CALL SGEMM('T','N',dima_sort,dimb_sort,dim_common,alpha,sf_a
     &,dim_common,sf_b,dim_common,1.0,sf_c, dima_sort)
      else if ( (prec .ge. 5) .and. (prec .le. 8) ) then
         call sgemmreplacement('T','N',dima_sort,dimb_sort,dim_common
     &,alpha,sf_a,dim_common,sf_b,dim_common,1.0,sf_c,dima_sort,splita
     &,splitb,muls,modetype)
      endif
      if(prec.eq.2) then
         call truncate_sp2hp(sf_c, dimhhhh)
      else if(prec.eq.1) then
         call truncate_sp2bf(sf_c, dimhhhh)
      endif
      END IF
      END IF
      END IF
      END DO
      END DO
      CALL TCE_SORT_4_mp_s2d(sf_c,df_t,int_mb(k_range+h11b-1
     &),int_mb(k_range+h9b-1),int_mb(k_range+h2b-1),int_mb(k_range+h1b-1
     &),2,1,4,3,-1.0d0/2.0d0)
      CALL ADD_HASH_BLOCK(d_c,df_t,dimc,int_mb(k_c_offset),(h2b -
     & 1 + noab * (h1b - 1 + noab * (h11b - 1 + noab * (h9b - 1)))))
      next = NXTASK(nprocs, 1)
      END IF
      count = count + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      next = NXTASK(-nprocs, 1)
      call GA_SYNC()

      deallocate(sf_a,stat=e_a)
      deallocate(sf_b,stat=e_b)
      deallocate(sf_c,stat=e_c)
      deallocate(df_t,stat=e_t)
      if (e_a.ne.0) call errquit("MA pops a",0,MA_ERR)
      if (e_b.ne.0) call errquit("MA pops b",0,MA_ERR)
      if (e_c.ne.0) call errquit("MA pops c",0,MA_ERR)
      if (e_t.ne.0) call errquit("MA pops t",1,MA_ERR)
      RETURN
      END

      SUBROUTINE ccsd_t2_6_mp(d_a,k_a_offset,d_b,k_b_offset,d_c,
     &     k_c_offset, maxh, maxp, prec)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i0 ( p3 p4 h1 h2 )_vt + = -1/2 * Sum ( h11 h9 ) * t ( p3 p4 h9 h11 )_t * i1 ( h9 h11 h1 h2 )_v
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      integer, parameter :: sp = selected_real_kind(6, 37)
      integer, parameter :: dp = selected_real_kind(15, 307)
      INTEGER prec
      INTEGER d_a
      INTEGER k_a_offset
      INTEGER d_b
      INTEGER k_b_offset
      INTEGER d_c
      INTEGER k_c_offset
      INTEGER NXTASK
      INTEGER next
      INTEGER nprocs
      INTEGER count
      INTEGER p3b
      INTEGER p4b
      INTEGER h1b
      INTEGER h2b
      INTEGER dimc
      INTEGER l_cs
      INTEGER k_cs
      INTEGER h9b
      INTEGER h11b
      INTEGER p3b_1
      INTEGER p4b_1
      INTEGER h9b_1
      INTEGER h11b_1
      INTEGER h9b_2
      INTEGER h11b_2
      INTEGER h1b_2
      INTEGER h2b_2
      INTEGER dim_common
      INTEGER dima_sort
      INTEGER dima
      INTEGER dimb_sort
      INTEGER dimb
      INTEGER l_as
      INTEGER k_as
      INTEGER l_a
      INTEGER k_a
      INTEGER l_bs
      INTEGER k_bs
      INTEGER l_b
      INTEGER k_b
      INTEGER l_c
      INTEGER k_c
      DOUBLE PRECISION FACTORIAL
      INTEGER maxh, maxp, dimhhpp, dimhhhh, dimtemp
      EXTERNAL NXTASK
      EXTERNAL FACTORIAL
      real(kind=dp), allocatable :: df_t(:)
      real(kind=sp), allocatable :: sf_a(:)
      real(kind=sp), allocatable :: sf_b(:)
      real(kind=sp), allocatable :: sf_c(:)
      integer :: e_a,e_b,e_c,e_t
      real(kind=sp) alpha
      integer :: splita, splitb, muls
      character*1 modetype
      nprocs = GA_NNODES()
      count = 0
      next = NXTASK(nprocs, 1)

      dimhhpp = maxh*maxh*maxp*maxp
      dimhhhh = maxh*maxh*maxh*maxh
      dimtemp = max(dimhhpp, dimhhhh)

      allocate(sf_a(1:dimhhpp),stat=e_a)
      allocate(sf_b(1:dimhhhh),stat=e_b)
      allocate(sf_c(1:dimhhpp),stat=e_c)
      allocate(df_t(1:dimtemp),stat=e_t)
      if (e_a.ne.0) call errquit("MA a",dimhhpp,MA_ERR)
      if (e_b.ne.0) call errquit("MA b",dimhhhh,MA_ERR)
      if (e_c.ne.0) call errquit("MA c",dimhhpp,MA_ERR)
      if (e_t.ne.0) call errquit("MA t",dimtemp,MA_ERR)

      DO p3b = noab+1,noab+nvab
      DO p4b = p3b,noab+nvab
      DO h1b = 1,noab
      DO h2b = h1b,noab
      IF ((.not.restricted).or.(int_mb(k_spin+p3b-1)+int_mb(k_spin+p4b-1
     &)+int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1).ne.8)) THEN
      IF (int_mb(k_spin+p3b-1)+int_mb(k_spin+p4b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+h2b-1)) THEN
      IF (ieor(int_mb(k_sym+p3b-1),ieor(int_mb(k_sym+p4b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+h2b-1)))) .eq. ieor(irrep_v,irrep_t)) TH
     &EN
      IF (next.eq.count) THEN
      dimc = int_mb(k_range+p3b-1) * int_mb(k_range+p4b-1) * int_mb(k_ra
     &nge+h1b-1) * int_mb(k_range+h2b-1)
      CALL SFILL(dimc,0.0,sf_c,1)
      DO h9b = 1,noab
      DO h11b = h9b,noab
      IF (int_mb(k_spin+p3b-1)+int_mb(k_spin+p4b-1) .eq. int_mb(k_spin+h
     &9b-1)+int_mb(k_spin+h11b-1)) THEN
      IF (ieor(int_mb(k_sym+p3b-1),ieor(int_mb(k_sym+p4b-1),ieor(int_mb(
     &k_sym+h9b-1),int_mb(k_sym+h11b-1)))) .eq. irrep_t) THEN
      CALL TCE_RESTRICTED_4(p3b,p4b,h9b,h11b,p3b_1,p4b_1,h9b_1,h11b_1)
      CALL TCE_RESTRICTED_4(h9b,h11b,h1b,h2b,h9b_2,h11b_2,h1b_2,h2b_2)
      dim_common = int_mb(k_range+h9b-1) * int_mb(k_range+h11b-1)
      dima_sort = int_mb(k_range+p3b-1) * int_mb(k_range+p4b-1)
      dima = dim_common * dima_sort
      dimb_sort = int_mb(k_range+h1b-1) * int_mb(k_range+h2b-1)
      dimb = dim_common * dimb_sort
      IF ((dima .gt. 0) .and. (dimb .gt. 0)) THEN
      CALL GET_HASH_BLOCK(d_a,df_t,dima,int_mb(k_a_offset),(h11b_
     &1 - 1 + noab * (h9b_1 - 1 + noab * (p4b_1 - noab - 1 + nvab * (p3b
     &_1 - noab - 1)))))
      CALL TCE_SORT_4_mp_d2s(df_t,sf_a,int_mb(k_range+p3b-1)
     &,int_mb(k_range+p4b-1),int_mb(k_range+h9b-1),int_mb(k_range+h11b-1
     &),2,1,4,3,1.0d0)
      CALL GET_HASH_BLOCK(d_b,df_t,dimb,int_mb(k_b_offset),(h2b_2
     & - 1 + noab * (h1b_2 - 1 + noab * (h11b_2 - 1 + noab * (h9b_2 - 1)
     &))))
      CALL TCE_SORT_4_mp_d2s(df_t,sf_b,int_mb(k_range+h9b-1)
     &,int_mb(k_range+h11b-1),int_mb(k_range+h1b-1),int_mb(k_range+h2b-1
     &),4,3,2,1,1.0d0)
      IF (h9b .eq. h11b) THEN
         alpha = 1.0
      ELSE
         alpha = 2.0
      END IF
      if(prec.eq.2) then
         call truncate_sp2hp(sf_a, dimhhpp)
         call truncate_sp2hp(sf_b, dimhhhh)
      else if(prec.eq.1) then
         call truncate_sp2bf(sf_a, dimhhpp)
         call truncate_sp2bf(sf_b, dimhhhh)
      endif
!     CALL SGEMM('T','N',dima_sort,dimb_sort,dim_common,alpha
!    &,sf_a,dim_common,sf_b,dim_common,1.0,sf_c,dima_sort)
!     prec = 1: BF16x1
!     prec = 2: FP16x1
!     prec = 3: FP32
!     prec = 4: FP64: I have no idea how this is done...
!     prec = 5: BF16x2
!     prec = 6: BF16x3
!     prec = 7: FP16x2
!     prec = 8: FP16x3
      if ( (prec .eq. 1) .or. (prec .eq. 5) .or. (prec .eq. 6) ) then
         modetype = 'B'
      else if ( (prec.eq.2) .or. (prec.eq.7) .or. (prec .eq. 8) ) then
         modetype = 'F'
      endif
      if ( (prec .eq. 5) .or. (prec .eq. 7) ) then
         splita = 2
         splitb = 2
         muls = 3
      endif
      if ( (prec .eq. 6) .or. (prec .eq. 8) ) then
         splita = 3
         splitb = 3
         muls = 6
      endif
      if ( prec .eq. 3 ) then
         CALL SGEMM('T','N',dima_sort,dimb_sort,dim_common,alpha,sf_a
     &,dim_common,sf_b,dim_common,1.0,sf_c, dima_sort)
      else if ( (prec .ge. 5) .and. (prec .le. 8) ) then
         call sgemmreplacement('T','N',dima_sort,dimb_sort,dim_common
     &,alpha,sf_a,dim_common,sf_b,dim_common,1.0,sf_c,dima_sort,splita
     &,splitb,muls,modetype)
      endif
      if(prec.eq.2) then
         call truncate_sp2hp(sf_c, dimhhpp)
      else if(prec.eq.1) then
         call truncate_sp2bf(sf_c, dimhhpp)
      endif
      END IF
      END IF
      END IF
      END DO
      END DO
      CALL TCE_SORT_4_mp_s2d(sf_c,df_t,int_mb(k_range+h2b-1)
     &,int_mb(k_range+h1b-1),int_mb(k_range+p4b-1),int_mb(k_range+p3b-1)
     &,4,3,2,1,-1.0d0/2.0d0)
      CALL ADD_HASH_BLOCK(d_c,df_t,dimc,int_mb(k_c_offset),(h2b -
     & 1 + noab * (h1b - 1 + noab * (p4b - noab - 1 + nvab * (p3b - noab
     & - 1)))))
      next = NXTASK(nprocs, 1)
      END IF
      count = count + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      next = NXTASK(-nprocs, 1)
      call GA_SYNC()

      deallocate(sf_a,stat=e_a)
      deallocate(sf_b,stat=e_b)
      deallocate(sf_c,stat=e_c)
      deallocate(df_t,stat=e_t)
      if (e_a.ne.0) call errquit("MA pops a",0,MA_ERR)
      if (e_b.ne.0) call errquit("MA pops b",0,MA_ERR)
      if (e_c.ne.0) call errquit("MA pops c",0,MA_ERR)
      if (e_t.ne.0) call errquit("MA pops t",1,MA_ERR)
      RETURN
      END

      SUBROUTINE ccsd_t2_2_2_3_mp(d_a,k_a_offset,d_b,k_b_offset,d_c,
     &     k_c_offset, maxh, maxp, prec)
C     $Id$
C     This is a Fortran77 program generated by Tensor Contraction Engine v.1.0
C     Copyright (c) Battelle & Pacific Northwest National Laboratory (2002)
C     i2 ( h10 h11 h1 h2 )_vt + = -1/2 * Sum ( p7 p8 ) * t ( p7 p8 h1 h2 )_t * v ( h10 h11 p7 p8 )_v
      IMPLICIT NONE
#include "global.fh"
#include "mafdecls.fh"
#include "sym.fh"
#include "errquit.fh"
#include "tce.fh"
      integer, parameter :: sp = selected_real_kind(6, 37)
      integer, parameter :: dp = selected_real_kind(15, 307)
      INTEGER prec
      INTEGER d_a
      INTEGER k_a_offset
      INTEGER d_b
      INTEGER k_b_offset
      INTEGER d_c
      INTEGER k_c_offset
      INTEGER NXTASK
      INTEGER next
      INTEGER nprocs
      INTEGER count
      INTEGER h10b
      INTEGER h11b
      INTEGER h1b
      INTEGER h2b
      INTEGER dimc
      INTEGER l_cs
      INTEGER k_cs
      INTEGER p7b
      INTEGER p8b
      INTEGER p7b_1
      INTEGER p8b_1
      INTEGER h1b_1
      INTEGER h2b_1
      INTEGER h10b_2
      INTEGER h11b_2
      INTEGER p7b_2
      INTEGER p8b_2
      INTEGER dim_common
      INTEGER dima_sort
      INTEGER dima
      INTEGER dimb_sort
      INTEGER dimb
      INTEGER l_as
      INTEGER k_as
      INTEGER l_a
      INTEGER k_a
      INTEGER l_bs
      INTEGER k_bs
      INTEGER l_b
      INTEGER k_b
      INTEGER l_c
      INTEGER k_c
      DOUBLE PRECISION FACTORIAL
      INTEGER maxh, maxp, dimhhpp, dimhhhh, dimtemp
      EXTERNAL NXTASK
      EXTERNAL FACTORIAL
      real(kind=dp), allocatable :: df_t(:)
      real(kind=sp), allocatable :: sf_a(:)
      real(kind=sp), allocatable :: sf_b(:)
      real(kind=sp), allocatable :: sf_c(:)
      integer :: e_a,e_b,e_c,e_t
      integer :: i
      real(kind=sp) alpha
      integer :: splita, splitb, muls
      character*1 modetype
      nprocs = GA_NNODES()
      count = 0
      next = NXTASK(nprocs, 1)

      dimhhpp = maxh*maxh*maxp*maxp
      dimhhhh = maxh*maxh*maxh*maxh
      dimtemp = max(dimhhpp, dimhhhh)

      allocate(sf_a(1:dimhhpp),stat=e_a)
      allocate(sf_b(1:dimhhpp),stat=e_b)
      allocate(sf_c(1:dimhhhh),stat=e_c)
      allocate(df_t(1:dimtemp),stat=e_t)
      if (e_a.ne.0) call errquit("MA a",dimhhpp,MA_ERR)
      if (e_b.ne.0) call errquit("MA b",dimhhpp,MA_ERR)
      if (e_c.ne.0) call errquit("MA c",dimhhhh,MA_ERR)
      if (e_t.ne.0) call errquit("MA t",dimtemp,MA_ERR)

      DO h10b = 1,noab
      DO h11b = h10b,noab
      DO h1b = 1,noab
      DO h2b = h1b,noab
      IF ((.not.restricted).or.(int_mb(k_spin+h10b-1)+int_mb(k_spin+h11b
     &-1)+int_mb(k_spin+h1b-1)+int_mb(k_spin+h2b-1).ne.8)) THEN
      IF (int_mb(k_spin+h10b-1)+int_mb(k_spin+h11b-1) .eq. int_mb(k_spin
     &+h1b-1)+int_mb(k_spin+h2b-1)) THEN
      IF (ieor(int_mb(k_sym+h10b-1),ieor(int_mb(k_sym+h11b-1),ieor(int_m
     &b(k_sym+h1b-1),int_mb(k_sym+h2b-1)))) .eq. ieor(irrep_v,irrep_t)) 
     &THEN
      IF (next.eq.count) THEN
      dimc = int_mb(k_range+h10b-1) * int_mb(k_range+h11b-1) * int_mb(k_
     &range+h1b-1) * int_mb(k_range+h2b-1)
      CALL SFILL(dimc,0.0,sf_c,1)
      DO p7b = noab+1,noab+nvab
      DO p8b = p7b,noab+nvab
      IF (int_mb(k_spin+p7b-1)+int_mb(k_spin+p8b-1) .eq. int_mb(k_spin+h
     &1b-1)+int_mb(k_spin+h2b-1)) THEN
      IF (ieor(int_mb(k_sym+p7b-1),ieor(int_mb(k_sym+p8b-1),ieor(int_mb(
     &k_sym+h1b-1),int_mb(k_sym+h2b-1)))) .eq. irrep_t) THEN
      CALL TCE_RESTRICTED_4(p7b,p8b,h1b,h2b,p7b_1,p8b_1,h1b_1,h2b_1)
      CALL TCE_RESTRICTED_4(h10b,h11b,p7b,p8b,h10b_2,h11b_2,p7b_2,p8b_2)
      dim_common = int_mb(k_range+p7b-1) * int_mb(k_range+p8b-1)
      dima_sort = int_mb(k_range+h1b-1) * int_mb(k_range+h2b-1)
      dima = dim_common * dima_sort
      dimb_sort = int_mb(k_range+h10b-1) * int_mb(k_range+h11b-1)
      dimb = dim_common * dimb_sort
      IF ((dima .gt. 0) .and. (dimb .gt. 0)) THEN
      CALL GET_HASH_BLOCK(d_a,df_t,dima,int_mb(k_a_offset),(h2b_1
     & - 1 + noab * (h1b_1 - 1 + noab * (p8b_1 - noab - 1 + nvab * (p7b_
     &1 - noab - 1)))))
      CALL TCE_SORT_4_mp_d2s(df_t,sf_a,int_mb(k_range+p7b-1)
     &,int_mb(k_range+p8b-1),int_mb(k_range+h1b-1),int_mb(k_range+h2b-1)
     &,4,3,2,1,1.0d0)
      if(.not.intorb) then
      CALL GET_HASH_BLOCK(d_b,df_t,dimb,int_mb(k_b_offset),(p8b_2
     & - 1 + (noab+nvab) * (p7b_2 - 1 + (noab+nvab) * (h11b_2 - 1 + (noa
     &b+nvab) * (h10b_2 - 1)))))
      else
      CALL GET_HASH_BLOCK_I(d_b,df_t,dimb,int_mb(k_b_offset),
     &(p8b_2
     & - 1 + (noab+nvab) * (p7b_2 - 1 + (noab+nvab) * (h11b_2 - 1 + (noa
     &b+nvab) * (h10b_2 - 1)))),p8b_2,p7b_2,h11b_2,h10b_2)
      end if
      CALL TCE_SORT_4_mp_d2s(df_t,sf_b,int_mb(k_range+h10b-1
     &),int_mb(k_range+h11b-1),int_mb(k_range+p7b-1),int_mb(k_range+p8b-
     &1),2,1,4,3,1.0d0)
      IF (p7b .eq. p8b) THEN
         alpha = 1.0
      ELSE
         alpha = 2.0
      END IF
      if(prec.eq.2) then
         call truncate_sp2hp(sf_a, dimhhpp)
         call truncate_sp2hp(sf_b, dimhhpp)
      else if(prec.eq.1) then
         call truncate_sp2bf(sf_a, dimhhpp)
         call truncate_sp2bf(sf_b, dimhhpp)
      endif
!     CALL SGEMM('T','N',dima_sort,dimb_sort,dim_common,alpha
!    &,sf_a,dim_common,sf_b,dim_common,1.0,sf_c,dima_sort)
!     prec = 1: BF16x1
!     prec = 2: FP16x1
!     prec = 3: FP32
!     prec = 4: FP64: I have no idea how this is done...
!     prec = 5: BF16x2
!     prec = 6: BF16x3
!     prec = 7: FP16x2
!     prec = 8: FP16x3
      if ( (prec .eq. 1) .or. (prec .eq. 5) .or. (prec .eq. 6) ) then
         modetype = 'B'
      else if ( (prec.eq.2) .or. (prec.eq.7) .or. (prec .eq. 8) ) then
         modetype = 'F'
      endif
      if ( (prec .eq. 5) .or. (prec .eq. 7) ) then
         splita = 2
         splitb = 2
         muls = 3
      endif
      if ( (prec .eq. 6) .or. (prec .eq. 8) ) then
         splita = 3
         splitb = 3
         muls = 6
      endif
      if ( prec .eq. 3 ) then
         CALL SGEMM('T','N',dima_sort,dimb_sort,dim_common,alpha,sf_a
     &,dim_common,sf_b,dim_common,1.0,sf_c, dima_sort)
      else if ( (prec .ge. 5) .and. (prec .le. 8) ) then
         call sgemmreplacement('T','N',dima_sort,dimb_sort,dim_common
     &,alpha,sf_a,dim_common,sf_b,dim_common,1.0,sf_c,dima_sort,splita
     &,splitb,muls,modetype)
      endif
      if(prec.eq.2) then
         call truncate_sp2hp(sf_c, dimhhhh)
      else if(prec.eq.1) then
         call truncate_sp2bf(sf_c, dimhhhh)
      endif
      END IF
      END IF
      END IF
      END DO
      END DO
      CALL TCE_SORT_4_mp_s2d(sf_c,df_t,int_mb(k_range+h11b-1
     &),int_mb(k_range+h10b-1),int_mb(k_range+h2b-1),int_mb(k_range+h1b-
     &1),2,1,4,3,-1.0d0/2.0d0)
      CALL ADD_HASH_BLOCK(d_c,df_t,dimc,int_mb(k_c_offset),(h2b -
     & 1 + noab * (h1b - 1 + noab * (h11b - 1 + noab * (h10b - 1)))))
      next = NXTASK(nprocs, 1)
      END IF
      count = count + 1
      END IF
      END IF
      END IF
      END DO
      END DO
      END DO
      END DO
      next = NXTASK(-nprocs, 1)
      call GA_SYNC()

      deallocate(sf_a,stat=e_a)
      deallocate(sf_b,stat=e_b)
      deallocate(sf_c,stat=e_c)
      deallocate(df_t,stat=e_t)
      if (e_a.ne.0) call errquit("MA pops a",0,MA_ERR)
      if (e_b.ne.0) call errquit("MA pops b",0,MA_ERR)
      if (e_c.ne.0) call errquit("MA pops c",0,MA_ERR)
      if (e_t.ne.0) call errquit("MA pops t",1,MA_ERR)
      RETURN
      END
